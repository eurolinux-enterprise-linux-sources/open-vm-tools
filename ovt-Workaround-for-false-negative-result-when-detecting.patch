From c567bef4b4f7721ef5c0444f464a9843ba609ae2 Mon Sep 17 00:00:00 2001
From: Miroslav Rezanina <mrezanin@redhat.com>
Date: Thu, 2 Aug 2018 17:14:28 +0200
Subject: [PATCH] Workaround for false negative result when detecting
 cloud-init existance

RH-Author: Miroslav Rezanina <mrezanin@redhat.com>
Message-id: <1533230068-14044-1-git-send-email-mrezanin@redhat.com>
Patchwork-id: 81615
O-Subject: [RHEL-7.6 open-vm-tools PATCH] Workaround for false negative result when detecting cloud-init existance
Bugzilla: 1601559
RH-Acked-by: Richard Jones <rjones@redhat.com>
RH-Acked-by: Cathy Avery <cavery@redhat.com>

From: Oliver Kurth <okurth@vmware.com>

"cloud-init -v" cmd is used to detect if cloud-init is properly configured and
it works on most linux distros. However in some linux distro like Amazon Linux 2,
"cloud-init -v" will print result to stderr instead of stdout and it makes
"forkExecAndWaitCommand" give false negative result.

1. added a new bool switch in  "ForkExecAndWaitCommand" to choose
   if we should ignore the stderr output when the return code is 0
2. removed unnecessary reference for "ForkExecAndWaitCommand" in linuxDeploymentUtilities.c
3. trivial change for some formatting

(cherry picked from commit 443eced089b634176c6ad1f56512a43381997abc)
Signed-off-by: Miroslav Rezanina <mrezanin@redhat.com>
---
 libDeployPkg/linuxDeployment.c       | 55 ++++++++++++++--------
 libDeployPkg/linuxDeploymentUtilities.c        |  3 +-
 2 files changed, 37 insertions(+), 21 deletions(-)

diff --git a/libDeployPkg/linuxDeployment.c b/libDeployPkg/linuxDeployment.c
index 023d41f..7bcdd0a 100644
--- a/libDeployPkg/linuxDeployment.c
+++ b/libDeployPkg/linuxDeployment.c
@@ -143,7 +143,7 @@ static bool CopyFileToDirectory(const char* srcPath, const char* destPath,
                                 const char* fileName);
 static int Deploy(const char* pkgName);
 static char** GetFormattedCommandLine(const char* command);
-int ForkExecAndWaitCommand(const char* command);
+int ForkExecAndWaitCommand(const char* command, bool ignoreStdErr);
 static void SetDeployError(const char* format, ...);
 static const char* GetDeployError(void);
 static void NoLogging(int level, const char* fmtstr, ...);
@@ -920,7 +920,7 @@ CloudInitSetup(const char *tmpDirPath)
             "/bin/mkdir -p %s", cloudInitTmpDirPath);
    command[sizeof(command) - 1] = '\0';
 
-   forkExecResult = ForkExecAndWaitCommand(command);
+   forkExecResult = ForkExecAndWaitCommand(command, false);
    if (forkExecResult != 0) {
       SetDeployError("Error creating %s dir: %s",
                      cloudInitTmpDirPath,
@@ -937,7 +937,7 @@ CloudInitSetup(const char *tmpDirPath)
             "/usr/bin/test -f %s/nics.txt", tmpDirPath);
    command[sizeof(command) - 1] = '\0';
 
-   forkExecResult = ForkExecAndWaitCommand(command);
+   forkExecResult = ForkExecAndWaitCommand(command, false);
 
    /*
     * /usr/bin/test -f returns 0 if the file exists
@@ -946,7 +946,7 @@ CloudInitSetup(const char *tmpDirPath)
     */
    if (forkExecResult == 0) {
       sLog(log_info, "nics.txt file exists. Copying..");
-      if(!CopyFileToDirectory(tmpDirPath, cloudInitTmpDirPath, "nics.txt")) {
+      if (!CopyFileToDirectory(tmpDirPath, cloudInitTmpDirPath, "nics.txt")) {
          goto done;
        }
    }
@@ -973,7 +973,7 @@ CloudInitSetup(const char *tmpDirPath)
    }
 
    sLog(log_info, "Copying main configuration file cust.cfg");
-   if(!CopyFileToDirectory(tmpDirPath, cloudInitTmpDirPath, "cust.cfg")) {
+   if (!CopyFileToDirectory(tmpDirPath, cloudInitTmpDirPath, "cust.cfg")) {
       goto done;
    }
 
@@ -992,7 +992,7 @@ done:
                   "/bin/rm -rf %s",
                   cloudInitTmpDirPath);
          command[sizeof(command) - 1] = '\0';
-         ForkExecAndWaitCommand(command);
+         ForkExecAndWaitCommand(command, false);
       }
       sLog(log_error, "Setting generic error status in vmx. \n");
       SetCustomizationStatusInVmx(TOOLSDEPLOYPKG_RUNNING,
@@ -1016,7 +1016,7 @@ CopyFileToDirectory(const char* srcPath, const char* destPath,
    snprintf(command, sizeof(command), "/bin/cp %s/%s %s/%s.tmp", srcPath,
             fileName, destPath, fileName);
    command[sizeof(command) - 1] = '\0';
-   forkExecResult = ForkExecAndWaitCommand(command);
+   forkExecResult = ForkExecAndWaitCommand(command, false);
    if (forkExecResult != 0) {
       SetDeployError("Error while copying file %s: %s", fileName,
                      strerror(errno));
@@ -1026,7 +1026,7 @@ CopyFileToDirectory(const char* srcPath, const char* destPath,
             fileName, destPath, fileName);
    command[sizeof(command) - 1] = '\0';
 
-   forkExecResult = ForkExecAndWaitCommand(command);
+   forkExecResult = ForkExecAndWaitCommand(command, false);
    if (forkExecResult != 0) {
       SetDeployError("Error while renaming temp file %s: %s", fileName,
                      strerror(errno));
@@ -1090,7 +1090,7 @@ UseCloudInitWorkflow(const char* dirPath)
       sLog(log_info, "cust.cfg is found in '%s' directory.", dirPath);
    }
 
-   forkExecResult = ForkExecAndWaitCommand(cloudInitCommand);
+   forkExecResult = ForkExecAndWaitCommand(cloudInitCommand, true);
    if (forkExecResult != 0) {
       sLog(log_info, "cloud-init is not installed");
       free(cfgFullPath);
@@ -1191,7 +1191,7 @@ Deploy(const char* packageName)
       deployStatus =  CloudInitSetup(tmpDirPath);
    } else {
       sLog(log_info, "Executing traditional GOSC workflow");
-      deploymentResult = ForkExecAndWaitCommand(command);
+      deploymentResult = ForkExecAndWaitCommand(command, false);
       free(command);
 
       if (deploymentResult != CUST_SUCCESS) {
@@ -1257,7 +1257,7 @@ Deploy(const char* packageName)
    strcat(cleanupCommand, tmpDirPath);
 
    sLog(log_info, "Launching cleanup. \n");
-   if (ForkExecAndWaitCommand(cleanupCommand) != 0) {
+   if (ForkExecAndWaitCommand(cleanupCommand, false) != 0) {
       sLog(log_warning, "Error while clean up tmp directory %s: (%s)",
            tmpDirPath, strerror (errno));
    }
@@ -1286,7 +1286,7 @@ Deploy(const char* packageName)
          int rebootComandResult = 0;
          do {
             sLog(log_info, "Rebooting\n");
-            rebootComandResult = ForkExecAndWaitCommand("/sbin/telinit 6");
+            rebootComandResult = ForkExecAndWaitCommand("/sbin/telinit 6", false);
             sleep(1);
          } while (rebootComandResult == 0);
          sLog(log_error, "telinit returned error %d\n", rebootComandResult);
@@ -1497,11 +1497,12 @@ GetFormattedCommandLine(const char* command)
  * fork-and-exec.
  *
  * @param   [IN]  command  Command to execute
+ * @param   [IN]  ignoreStdErr  If we ignore stderr when cmd's return code is 0
  * @return  Return code from the process (or DEPLOY_ERROR)
  *
  **/
 int
-ForkExecAndWaitCommand(const char* command)
+ForkExecAndWaitCommand(const char* command, bool ignoreStdErr)
 {
    ProcessHandle hp;
    int retval;
@@ -1519,14 +1520,30 @@ ForkExecAndWaitCommand(const char* command)
 
    Process_RunToComplete(hp, 100);
    sLog(log_info, "Customization command output: %s\n", Process_GetStdout(hp));
-
-   if(Process_GetExitCode(hp) == 0 && strlen(Process_GetStderr(hp)) > 0) {
-      // Assume command failed if it wrote to stderr, even if exitCode is 0
-      sLog(log_error, "Customization command failed: %s\n", Process_GetStderr(hp));
-      retval = -1;
+   retval = Process_GetExitCode(hp);
+
+   if (retval == 0) {
+      if (strlen(Process_GetStderr(hp)) > 0) {
+         if (!ignoreStdErr) {
+            // Assume command failed if it wrote to stderr, even if exitCode is 0
+            sLog(log_error,
+                 "Customization command failed with stderr: %s\n",
+                 Process_GetStderr(hp));
+            retval = -1;
+         } else {
+            // If we choose to ignore stderr, we do not return -1 when return
+            // code is 0. e.g, PR2148977, "cloud-init -v" will return 0
+            // even there is output in stderr
+            sLog(log_info, "Ignoring stderr output: %s\n", Process_GetStderr(hp));
+         }
+      }
    } else {
-      retval = Process_GetExitCode(hp);
+      sLog(log_error,
+           "Customization command failed with exitcode: %d, stderr: %s\n",
+           retval,
+           Process_GetStderr(hp));
    }
+
    Process_Destroy(hp);
    return retval;
 }
diff --git a/libDeployPkg/linuxDeploymentUtilities.c b/libDeployPkg/linuxDeploymentUtilities.c
index 83f942d..93e1b0a 100644
--- a/libDeployPkg/linuxDeploymentUtilities.c
+++ b/libDeployPkg/linuxDeploymentUtilities.c
@@ -1,5 +1,5 @@
 /*********************************************************
- * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
+ * Copyright (C) 2016-2018 VMware, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as published
@@ -24,7 +24,6 @@
 #include <regex.h>
 #include "linuxDeploymentUtilities.h"
 
-extern int ForkExecAndWaitCommand(const char* command);
 extern LogFunction sLog;
 
 /**
-- 
1.8.3.1

